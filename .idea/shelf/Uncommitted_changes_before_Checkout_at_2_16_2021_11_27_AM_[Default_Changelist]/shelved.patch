Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Auto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// FTC Team 7080 BACON\r\n// Autonomous code 2020-2021\r\n\r\n        package org.firstinspires.ftc.teamcode;\r\n\r\n// All imports here that are not commented out are likely reusable and helpful for this coming year\r\n\r\n//These three lines I believe work with the app on the phone. Not sure if the color one is something we need to think about for this year...\r\n        import android.app.Activity;\r\n        import android.graphics.Color;\r\n        import android.view.View;\r\n\r\n        import com.qualcomm.hardware.rev.RevBlinkinLedDriver;\r\n\r\n//imports related to the opmode\r\n        import com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\n        import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\n        import com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\n\r\n//Sensors and motors...\r\n        import com.qualcomm.robotcore.hardware.ColorSensor;\r\n        import com.qualcomm.robotcore.hardware.DistanceSensor;\r\n        import com.qualcomm.hardware.rev.Rev2mDistanceSensor;\r\n        import com.qualcomm.robotcore.hardware.DcMotor;\r\n        import com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n\r\n//Imports related to navigation and motion (Driving) (Vuforia)\r\n        import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\n        import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;\r\n        import static org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer.CameraDirection.BACK;\r\n\r\n// Hardware map\r\n        import org.firstinspires.ftc.teamcode.HardwareBACONbot;\r\n\r\n        import java.util.Locale;\r\n\r\n//import javax.print.attribute.Size2DSyntax;\r\n\r\n//import org.firstinspires.ftc.teamcode.Teleops.HardwareMap;\r\n\r\n//Imports Abby is adding (color sensing)\r\n        import org.opencv.core.Core;\r\n        import org.opencv.core.Mat;\r\n        import org.opencv.core.Point;\r\n        import org.opencv.core.Rect;\r\n        import org.opencv.core.Scalar;\r\n        import org.opencv.imgproc.Imgproc;\r\n        import org.openftc.easyopencv.OpenCvCamera;\r\n        import org.openftc.easyopencv.OpenCvCameraFactory;\r\n        import org.openftc.easyopencv.OpenCvCameraRotation;\r\n        import org.openftc.easyopencv.OpenCvInternalCamera;\r\n        import org.openftc.easyopencv.OpenCvPipeline;\r\n\r\n\r\n        @Autonomous(name = \"BACON: Autonomous 2021\", group = \"Opmode\")\r\n//@Disabled\r\n\r\n\r\n        public class Auto extends LinearOpMode {\r\n        private ElapsedTime runtime = new ElapsedTime();\r\n\r\n        HardwareBACONbot robot = new HardwareBACONbot();\r\n\r\n        //OpenCV stuff\r\n        OpenCvInternalCamera phoneCam;\r\n        SkystoneDeterminationPipeline pipeline;\r\n\r\n        // === DEFINE CONSTANTS HERE! ===\r\n\r\n    /*double STRAFE_SPEED = 0.3;  // Motor power global variables\r\n    double FAST_SPEED = 1.0;\r\n    double SLOW_SPEED = 0.2;*/\r\n\r\n        //Here is where ints will go:\r\n        //For example:\r\n        // int blueTape/redTape = color sensor value\r\n        // int blue/red = 1 or 0 depending on situation\r\n        // int left/right = 0 or 1 depending on situation\r\n        // int madeUpVariable; to initialize a variable\r\n        // int distance = value of distace sensor to desired location at point of initialization\r\n        int RINGDIST = 860;\r\n\r\n\r\n        // ==============================\r\n        public void runOpMode() {\r\n        //OpenCV stuff\r\n        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        phoneCam = OpenCvCameraFactory.getInstance().createInternalCamera(OpenCvInternalCamera.CameraDirection.BACK, cameraMonitorViewId);\r\n        pipeline = new SkystoneDeterminationPipeline();\r\n        phoneCam.setPipeline(pipeline);\r\n        phoneCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\r\n\r\n        phoneCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\r\n        {\r\n        @Override\r\n        public void onOpened()\r\n        {\r\n        phoneCam.startStreaming(320,240, OpenCvCameraRotation.SIDEWAYS_LEFT);\r\n        }\r\n        });\r\n\r\n\r\n        int teamcolor = 0; // 1 = Blue 2 = Red\r\n        int blue = 1;\r\n        int red = 2;\r\n\r\n        int task = 0; //1 = drop&park  2 = fullRun\r\n        int dropPark = 1;\r\n        int fullRun = 2;\r\n\r\n        int side = 0; // 1 = left side start 2 = right side start\r\n\r\n        double meetDistance = 860; //Distance from wall to the rings (CM From Wall (BackSensor))\r\n\r\n        double lastTime = runtime.milliseconds();\r\n\r\n        // wobbleServo and tiltServo states\r\n        float grabPos = 0;\r\n        float freePos = 1;\r\n        float upTilt = 0;\r\n        float downTilt = 1;\r\n\r\n        Orientation angles;\r\n        Acceleration gravity;\r\n\r\n        robot.init(hardwareMap);\r\n\r\n        // Choosing the team color\r\n        telemetry.addData(\"Press X for Blue, B for Red\", \"\");\r\n        telemetry.update();\r\n        //Call component setup functions here: ex. openClaw, raiseLauncher, etc.\r\n\r\n        //It will only assign color if the buttons are pressed\r\n        while (!gamepad1.x && !gamepad1.b) {\r\n        }\r\n\r\n        //This sets the strips of lights to the team color\r\n        if (gamepad1.x) {\r\n        teamcolor = blue;\r\n        robot.pattern = RevBlinkinLedDriver.BlinkinPattern.HEARTBEAT_BLUE;\r\n        robot.blinkinLedDriver.setPattern(robot.pattern);\r\n\r\n\r\n        }\r\n\r\n        if (gamepad1.b) {\r\n        teamcolor = red;\r\n        robot.pattern = RevBlinkinLedDriver.BlinkinPattern.HEARTBEAT_RED;\r\n        robot.blinkinLedDriver.setPattern(robot.pattern);\r\n\r\n\r\n        }\r\n\r\n\r\n        telemetry.addData(\"teamcolor \", teamcolor);\r\n        telemetry.update();\r\n\r\n        // Choosing task\r\n        telemetry.addData(\"Press A for drop&park, Y for fullRun\", \"\");\r\n        telemetry.update();\r\n        while (!gamepad1.a && !gamepad1.y) {\r\n        }\r\n        if (gamepad1.a) {\r\n        task = dropPark;\r\n        }\r\n        if (gamepad1.y) {\r\n        task = fullRun ;\r\n        }\r\n        telemetry.addData(\"task \", task);\r\n        telemetry.update();\r\n\r\n        Rev2mDistanceSensor sensorTimeOfFlight = (Rev2mDistanceSensor) robot.backDistance;\r\n\r\n        //Wobble grabber position\r\n        robot.wobbleServo.setPosition(grabPos);\r\n        robot.tiltServo.setPosition(upTilt);\r\n\r\n        waitForStart();\r\n        runtime.reset();\r\n\r\n        //OpenCV stuff\r\n        telemetry.addData(\"Analysis\", pipeline.getAnalysis());\r\n        telemetry.addData(\"Position\", pipeline.position);\r\n        telemetry.update();\r\n        // Don't burn CPU cycles busy-looping in this sample\r\n        sleep(50);\r\n\r\n        // run until the end of the match (when driver presses STOP)\r\n\r\n\r\n\r\n\r\n\r\n        //fullRun --------------------------------------------------------------------------------------------------------------------------\r\n\r\n        //First troubleshooting steps for this section would be to check the direction of the strafes in scan and grab\r\n        if ((task == fullRun) && (teamcolor == red)) {\r\n        initializeWhiteLight();\r\n        //This gets the robot in the proper place to sense the rings\r\n        positionRobot();\r\n        //Navigating to the correct square\r\n        wobblePosition();\r\n        //Place the wobble goal in the square\r\n        wobbleDrop();\r\n        park();\r\n        //go drop the wobble goal in the correct zone and return to the parking line\r\n        stopDriving();\r\n        //To powershot\r\n        launchRing();\r\n\r\n        }\r\n        if ((task == fullRun) && (teamcolor == blue)) {\r\n        initializeWhiteLight();\r\n        //This gets the robot in the proper place to sense the rings\r\n        positionRobot();\r\n        //Navigating to the correct square\r\n        wobblePosition();\r\n        //Place the wobble goal in the square\r\n        wobbleDrop();\r\n        //go drop the wobble goal in the correct zone and return to the parking line\r\n        park();\r\n        stopDriving();\r\n        //To powershot\r\n        launchRing();\r\n\r\n        }\r\n\r\n        //drop&park------------------------------------------------------------------------------------------------\r\n        if ((task == dropPark) && (teamcolor == red)) {\r\n        initializeWhiteLight();\r\n        //This gets the robot in the proper place to sense the rings\r\n        positionRobot();\r\n        //Navigating to the correct square\r\n        wobblePosition();\r\n        //Place the wobble goal in the square\r\n        wobbleDrop();\r\n        park();\r\n        //go drop the wobble goal in the correct zone and return to the parking line\r\n        stopDriving();\r\n\r\n        }\r\n        if ((task == dropPark) && (teamcolor == blue)) {\r\n        initializeWhiteLight();\r\n        //This gets the robot in the proper place to sense the rings\r\n        positionRobot();\r\n        //Navigating to the correct square\r\n        wobblePosition();\r\n        //Place the wobble goal in the square\r\n        wobbleDrop();\r\n        //go drop the wobble goal in the correct zone and return to the parking line\r\n        park();\r\n        stopDriving();\r\n        }\r\n        //  -----------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n        }\r\n\r\n        // Functions ----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n        //Driving Functions_______________________________________________________________________________________________________________\r\n\r\n        //Stop Driving - Kill power to all the motors\r\n        void stopDriving() {\r\n\r\n        robot.frontLeftMotor.setPower(0);\r\n        robot.frontRightMotor.setPower(0);\r\n        robot.backLeftMotor.setPower(0);\r\n        robot.backRightMotor.setPower(0);\r\n\r\n        }\r\n\r\n        //Drive Backwards - Used for starting the game\r\n        void driveBackwards() {\r\n        robot.frontLeftMotor.setPower(-0.5);\r\n        robot.frontRightMotor.setPower(0.5);\r\n        robot.backLeftMotor.setPower(-0.5);\r\n        robot.backRightMotor.setPower(0.5);\r\n        }\r\n\r\n        //Drive Backwards Slow - Used for starting the game\r\n        void driveBackwardsSlow() {\r\n        robot.frontLeftMotor.setPower(-0.3);\r\n        robot.frontRightMotor.setPower(0.3);\r\n        robot.backLeftMotor.setPower(-0.3);\r\n        robot.backRightMotor.setPower(0.3);\r\n        }\r\n\r\n\r\n        //Drive Forwards - Towards where the Backsensor is facing\r\n        void driveForward() {\r\n        robot.frontLeftMotor.setPower(0.5);\r\n        robot.backLeftMotor.setPower(0.5);\r\n        robot.backRightMotor.setPower(-0.5);\r\n        robot.frontRightMotor.setPower(-0.5);\r\n        }\r\n\r\n        //Drive Forwards Slow- Towards where the Backsensor is facing\r\n        void driveForwardSlow() {\r\n        robot.frontLeftMotor.setPower(SLOW_SPEED);\r\n        robot.backLeftMotor.setPower(SLOW_SPEED);\r\n        robot.backRightMotor.setPower(-1 * SLOW_SPEED);\r\n        robot.frontRightMotor.setPower(-1 * SLOW_SPEED);\r\n        }\r\n\r\n\r\n\r\n        //Strafe Left - (used to strafe towards the center line for parking)\r\n        void strafeLeft(int side, double pwr, Orientation target) {  //added int pwr to reduce initial power\r\n        //Get the current orientation\r\n        Orientation currOrient;\r\n        currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        //Compare the current orientation to the target\r\n        double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n        double targAng = 0.0;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n        double error = targAng - currAng;\r\n        double frontLeft;\r\n        double frontRight;\r\n        double backLeft;\r\n        double backRight;\r\n        double max;\r\n        //scale the error so that it is a motor value and\r\n        //then scale it by a third of the power to make sure it\r\n        //doesn't dominate the movement\r\n        double r = -error / 180 * (pwr * 10);\r\n\r\n        /*\r\n        //if the absolute value of r is less than\r\n        //.07, the motors won't do anything, so if\r\n        //it is less than .07, make it .07\r\n        if ((r < .07) && (r > 0)) {\r\n            r = .07;\r\n        } else if ((r > -.07) && (r < 0)) {\r\n            r = -.07;\r\n        }\r\n        */\r\n\r\n/*\r\n        telemetry.addData(\"pwr:>\", pwr);\r\n        telemetry.addData(\"error:>\", r);\r\n        telemetry.addData(\"r:>\", r);\r\n        telemetry.update();\r\n*/\r\n        double d; // Front distance correction\r\n        d = -(FRONTDIST - 45 - robot.frontDistance.getDistance(DistanceUnit.MM)) / 200;\r\n        if (side == mat) {\r\n        d = 0;\r\n        }\r\n        // Normalize the values so none exceeds +/- 1.0\r\n        frontLeft = -pwr + r + d;\r\n        backLeft = pwr + r + d;\r\n        backRight = pwr + r - d;\r\n        frontRight = -pwr + r - d;\r\n        max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n        if (max > 1.0) {\r\n        frontLeft = frontLeft / max;\r\n        frontRight = frontRight / max;\r\n        backLeft = backLeft / max;\r\n        backRight = backRight / max;\r\n        }\r\n\r\n        //send the power to the motors\r\n        robot.frontLeftMotor.setPower(frontLeft);\r\n        robot.backLeftMotor.setPower(backLeft); //Changing the order in which the wheels start\r\n        robot.backRightMotor.setPower(backRight);\r\n        robot.frontRightMotor.setPower(frontRight);\r\n\r\n        }\r\n\r\n        void strafeRight(int side, double pwr, Orientation target) {  //added int pwr to reduce initial power\r\n        //Get the current orientation\r\n        Orientation currOrient;\r\n        currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        //Compare the current orientation to the target\r\n        double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n        double targAng = 0.0;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n        double error = targAng - currAng;\r\n        double frontLeft;\r\n        double frontRight;\r\n        double backLeft;\r\n        double backRight;\r\n        double max;\r\n        //scale the error so that it is a motor value and\r\n        //then scale it by a third of the power to make sure it\r\n        //doesn't dominate the movement\r\n        double r = -error / 180 * (pwr * 10);\r\n\r\n        //if the absolute value of r is less than\r\n        //.07, the motors won't do anything, so if\r\n        //it is less than .07, make it .07\r\n        /*\r\n        if ((r < .07) && (r > 0)) {\r\n            r = .07;\r\n        } else if ((r > -.07) && (r < 0)) {\r\n            r = -.07;\r\n        }\r\n        */\r\n/*\r\n        telemetry.addData(\"pwr:>\", pwr);\r\n        telemetry.addData(\"error:>\", r);\r\n        telemetry.addData(\"r:>\", r);\r\n        telemetry.update();\r\n*/\r\n        double d; // Front distance correction\r\n        d = -(FRONTDIST - 45 - robot.frontDistance.getDistance(DistanceUnit.MM)) / 200;\r\n        if (side == mat) {\r\n        d = 0;\r\n        }\r\n        // Normalize the values so none exceeds +/- 1.0\r\n        frontLeft = pwr + r + d;\r\n        backLeft = -pwr + r + d;\r\n        backRight = -pwr + r - d;\r\n        frontRight = pwr + r - d;\r\n        max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n        if (max > 1.0) {\r\n        frontLeft = frontLeft / max;\r\n        frontRight = frontRight / max;\r\n        backLeft = backLeft / max;\r\n        backRight = backRight / max;\r\n        }\r\n\r\n        //send the power to the motors\r\n        robot.frontLeftMotor.setPower(frontLeft);\r\n        robot.backLeftMotor.setPower(backLeft); //Changing the order in which the wheels start\r\n        robot.backRightMotor.setPower(backRight);\r\n        robot.frontRightMotor.setPower(frontRight);\r\n        }\r\n\r\n\r\n\r\n//start of graham addition\r\n\r\n\r\n\r\n        //drives straight for a desired distanced based off of the back distance sensor\r\n        void driveStraightDistance(double pwr, Orientation target, double desiredDistance){\r\n\r\n        //orients\r\n        Orientation targetOrient;\r\n        Orientation currOrient;\r\n\r\n\r\n        //converts the target heading to a double to use in error calculation\r\n        targetOrient = target;\r\n        double targAng = targetOrient.angleUnit.DEGREES.normalize(target.firstAngle);;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n\r\n        //rChanger changes the sensitivity of the R value\r\n        double rChanger = 10;\r\n        double frontLeft, frontRight, backLeft, backRight, max;\r\n\r\n        while(((robot.backDistance.getDistance(DistanceUnit.MM) < desiredDistance) && (opModeIsActive()))){\r\n\r\n        currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n\r\n        double error = targAng - currAng;\r\n\r\n\r\n        double r = (-error / 180) / (pwr);\r\n        //r = 0;\r\n\r\n        // Normalize the values so none exceeds +/- 1.0\r\n        frontLeft = pwr + r ;\r\n        backLeft = pwr + r ;\r\n        backRight = pwr - r ;\r\n        frontRight = pwr - r ;\r\n\r\n        frontLeft = -frontLeft;\r\n        backLeft = -backLeft;\r\n\r\n        max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n        if (max > 1.0) {\r\n        frontLeft = frontLeft / max;\r\n        frontRight = frontRight / max;\r\n        backLeft = backLeft / max;\r\n        backRight = backRight / max;\r\n        }\r\n\r\n\r\n\r\n        telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n        telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n        telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n        telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n        telemetry.addData(\"current heading\", formatAngle(currOrient.angleUnit, currOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", formatAngle(targetOrient.angleUnit, targetOrient.firstAngle));\r\n\r\n        telemetry.update();\r\n\r\n        //send the power to the motors\r\n        robot.frontLeftMotor.setPower(frontLeft);\r\n        robot.backLeftMotor.setPower(backLeft);\r\n        robot.backRightMotor.setPower(backRight);\r\n        robot.frontRightMotor.setPower(frontRight);\r\n\r\n\r\n\r\n        }\r\n\r\n        }\r\n\r\n        //drives forward at the heading it was called at\r\n        // for example, calling this when the robot is at 60 heading, it will go to that heading, even if it gets knocked off course\r\n        void driveStraightTime(double pwr, Orientation target, double desiredTime){\r\n\r\n        //orients\r\n        Orientation targetOrient;\r\n        Orientation currOrient;\r\n\r\n\r\n        double lastTime = runtime.milliseconds();\r\n\r\n        //converts the target heading to a double to use in error calculation\r\n        targetOrient = target;\r\n        double targAng = targetOrient.angleUnit.DEGREES.normalize(target.firstAngle);;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n\r\n        //rChanger changes the sensitivity of the R value\r\n        double rChanger = 10;\r\n        double frontLeft, frontRight, backLeft, backRight, max;\r\n\r\n        while(((runtime.milliseconds() < lastTime + desiredTime) && (opModeIsActive()))){\r\n\r\n\r\n\r\n        currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n\r\n        double error = targAng - currAng;\r\n\r\n\r\n        double r = (-error / 180) / (pwr);\r\n        //r = 0;\r\n\r\n        // Normalize the values so none exceeds +/- 1.0\r\n        frontLeft = pwr + r ;\r\n        backLeft = pwr + r ;\r\n        backRight = pwr - r ;\r\n        frontRight = pwr - r ;\r\n\r\n        frontLeft = -frontLeft;\r\n        backLeft = -backLeft;\r\n\r\n        max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n        if (max > 1.0) {\r\n        frontLeft = frontLeft / max;\r\n        frontRight = frontRight / max;\r\n        backLeft = backLeft / max;\r\n        backRight = backRight / max;\r\n        }\r\n\r\n\r\n\r\n        telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n        telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n        telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n        telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n        telemetry.addData(\"current heading\", formatAngle(currOrient.angleUnit, currOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", formatAngle(targetOrient.angleUnit, targetOrient.firstAngle));\r\n\r\n        telemetry.update();\r\n\r\n        //send the power to the motors\r\n        robot.frontLeftMotor.setPower(frontLeft);\r\n        robot.backLeftMotor.setPower(backLeft);\r\n        robot.backRightMotor.setPower(backRight);\r\n        robot.frontRightMotor.setPower(frontRight);\r\n\r\n\r\n\r\n        }\r\n\r\n        }\r\n\r\n\r\n        //rotates to the given heading\r\n        void rotateToHeading(double heading){\r\n\r\n        Orientation currentOrient;\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        double currentAngle = currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle);\r\n\r\n        for (double i = .3; i > .1; i = i-.1) {\r\n\r\n        blindRotateRight(i);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) > heading) && opModeIsActive()) {\r\n\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", heading);\r\n        telemetry.update();\r\n        }\r\n        stopDriving();\r\n\r\n        blindRotateLeft(i);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) < heading) && opModeIsActive()) {\r\n\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", heading);\r\n        telemetry.update();\r\n        }\r\n        stopDriving();\r\n        }\r\n\r\n\r\n\r\n        blindRotateRight(.175);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) > heading) && opModeIsActive()) {\r\n\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", heading);\r\n        telemetry.update();\r\n        }\r\n        stopDriving();\r\n\r\n\r\n\r\n\r\n        blindRotateLeft(.175);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) < heading) && opModeIsActive()) {\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n        telemetry.addData(\"target heading\", heading);\r\n        telemetry.update();\r\n        }\r\n        stopDriving();\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        //just rotates to the right\r\n        void blindRotateRight(double pwr){\r\n        pwr = -pwr; // -pwr on all wheels turns right\r\n        // Set power on each wheel\r\n        robot.frontLeftMotor.setPower(pwr);\r\n        robot.frontRightMotor.setPower(pwr);\r\n        robot.backLeftMotor.setPower(pwr);\r\n        robot.backRightMotor.setPower(pwr);\r\n\r\n        }\r\n\r\n        //just rotates to the left\r\n        void blindRotateLeft(double pwr){\r\n\r\n        robot.frontLeftMotor.setPower(pwr);\r\n        robot.frontRightMotor.setPower(pwr);\r\n        robot.backLeftMotor.setPower(pwr);\r\n        robot.backRightMotor.setPower(pwr);\r\n\r\n        }\r\n//end of Graham Addition\r\n\r\n\r\n// Functions related to the wobble goal________________________________________________________________________________________________________\r\n\r\n        void wobbleUp() {\r\n        robot.tiltServo.setPosition(0);\r\n        }\r\n\r\n        void wobbleDown(){\r\n        robot.tiltServo.setPosition(1);\r\n        }\r\n\r\n        void wobbleOpen() {\r\n        robot.wobbleServo.setPosition(1);\r\n        }\r\n\r\n        void wobbleClose() {\r\n        robot.wobbleServo.setPosition(0);\r\n        }\r\n\r\n        void wobbleDrop() {\r\n        wobbleDown();\r\n        wobbleOpen();\r\n        telemetry.addData(\"Wobble goal delivered\", 0);\r\n        telemetry.update();\r\n        }\r\n\r\n        void wobbleRaise() {\r\n        wobbleClose();\r\n        wobbleUp();\r\n        telemetry.addData(\"Wobble goal up\", 0);\r\n        telemetry.update();\r\n        }\r\n\r\n        //Scan Function_______________________________________________________________________________________________________________\r\n\r\n        public static class SkystoneDeterminationPipeline extends OpenCvPipeline\r\n        {\r\n        /*\r\n         * An enum to define the skystone position\r\n         */\r\n        public enum RingPosition\r\n        {\r\n        FOUR,\r\n        ONE,\r\n        NONE\r\n        }\r\n\r\n        /*\r\n         * Some color constants\r\n         */\r\n        static final Scalar BLUE = new Scalar(0, 0, 255);\r\n        static final Scalar GREEN = new Scalar(0, 255, 0);\r\n\r\n        /*\r\n         * The core values which define the location and size of the sample regions\r\n         */\r\n        static final Point REGION1_TOPLEFT_ANCHOR_POINT = new Point(181,98); //Change these to match up with where rings will be depending on phone placement\r\n\r\n        static final int REGION_WIDTH = 35;\r\n        static final int REGION_HEIGHT = 25;\r\n\r\n        final int FOUR_RING_THRESHOLD = 150; //Change these thresholds depending on our values\r\n        final int ONE_RING_THRESHOLD = 135;\r\n\r\n        Point region1_pointA = new Point(\r\n        REGION1_TOPLEFT_ANCHOR_POINT.x,\r\n        REGION1_TOPLEFT_ANCHOR_POINT.y);\r\n        Point region1_pointB = new Point(\r\n        REGION1_TOPLEFT_ANCHOR_POINT.x + REGION_WIDTH,\r\n        REGION1_TOPLEFT_ANCHOR_POINT.y + REGION_HEIGHT);\r\n\r\n        /*\r\n         * Working variables\r\n         */\r\n        Mat region1_Cb;\r\n        Mat YCrCb = new Mat();\r\n        Mat Cb = new Mat();\r\n        int avg1;\r\n\r\n        // Volatile since accessed by OpMode thread w/o synchronization\r\n        private volatile RingPosition position = RingPosition.FOUR;\r\n\r\n        /*\r\n         * This function takes the RGB frame, converts to YCrCb,\r\n         * and extracts the Cb channel to the 'Cb' variable\r\n         */\r\n        void inputToCb(Mat input)\r\n        {\r\n        Imgproc.cvtColor(input, YCrCb, Imgproc.COLOR_RGB2YCrCb);\r\n        Core.extractChannel(YCrCb, Cb, 1);\r\n        }\r\n\r\n        @Override\r\n        public void init(Mat firstFrame)\r\n        {\r\n        inputToCb(firstFrame);\r\n\r\n        region1_Cb = Cb.submat(new Rect(region1_pointA, region1_pointB));\r\n        }\r\n\r\n        @Override\r\n        public Mat processFrame(Mat input)\r\n        {\r\n        inputToCb(input);\r\n\r\n        avg1 = (int) Core.mean(region1_Cb).val[0];\r\n\r\n        Imgproc.rectangle(\r\n        input, // Buffer to draw on\r\n        region1_pointA, // First point which defines the rectangle\r\n        region1_pointB, // Second point which defines the rectangle\r\n        BLUE, // The color the rectangle is drawn in\r\n        2); // Thickness of the rectangle lines\r\n\r\n        position = RingPosition.FOUR; // Record our analysis\r\n        if(avg1 > FOUR_RING_THRESHOLD){\r\n        position = RingPosition.FOUR;\r\n        }else if (avg1 > ONE_RING_THRESHOLD){\r\n        position = RingPosition.ONE;\r\n        }else{\r\n        position = RingPosition.NONE;\r\n        }\r\n\r\n        Imgproc.rectangle(\r\n        input, // Buffer to draw on\r\n        region1_pointA, // First point which defines the rectangle\r\n        region1_pointB, // Second point which defines the rectangle\r\n        GREEN, // The color the rectangle is drawn in\r\n        -1); // Negative thickness means solid fill\r\n\r\n        return input;\r\n        }\r\n\r\n        public int getAnalysis()\r\n        {\r\n        return avg1;\r\n        }\r\n        }\r\n\r\n\r\n\r\n        void wobblePosition(){\r\n        if (NONE) {\r\n        }\r\n\r\n        if (ONE){\r\n\r\n        }\r\n\r\n        if (FOUR){\r\n\r\n        }\r\n\r\n        }\r\n\r\n        void positionRobot(){\r\n        //drive up to rings\r\n        }\r\n\r\n        void park(){\r\n        //park over white line\r\n        }\r\n\r\n        void launchRing(){\r\n        //to powershot\r\n        }\r\n\r\n        //Blinkin Function_______________________________________________________________________________________________________________\r\n        void initializeWhiteLight(){\r\n        robot.pattern = RevBlinkinLedDriver.BlinkinPattern.WHITE;\r\n        robot.blinkinLedDriver.setPattern(robot.pattern);\r\n        }\r\n\r\n\r\n\r\n\r\n        //----------------------------------------------------------------------------------------------\r\n        // Formatting\r\n        //----------------------------------------------------------------------------------------------\r\n\r\n        String formatAngle(AngleUnit angleUnit, double angle){\r\n        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\r\n        }\r\n\r\n        String formatDegrees(double degrees) {\r\n        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\r\n        }\r\n\r\n        }\r\n        © 2021 GitHub, Inc.\r\n        Terms\r\n        Privacy\r\n        Security\r\n        Status\r\n        Docs\r\n        Contact GitHub\r\n        Pricing\r\n        API\r\n        Training\r\n        Blog\r\n        About\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Auto.java	(revision ddb35de42b30ef7dd067532d4060f9d15d5b3fca)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Auto.java	(date 1613492851290)
@@ -180,7 +180,7 @@
 
         //Wobble grabber position
         robot.wobbleServo.setPosition(grabPos);
-        robot.tiltServo.setPosition(upTilt);
+        robot.tiltMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
 
         waitForStart();
         runtime.reset();
@@ -306,10 +306,10 @@
 
         //Drive Forwards Slow- Towards where the Backsensor is facing
         void driveForwardSlow() {
-        robot.frontLeftMotor.setPower(SLOW_SPEED);
-        robot.backLeftMotor.setPower(SLOW_SPEED);
-        robot.backRightMotor.setPower(-1 * SLOW_SPEED);
-        robot.frontRightMotor.setPower(-1 * SLOW_SPEED);
+        robot.frontLeftMotor.setPower(0.3);
+        robot.backLeftMotor.setPower(0.3);
+        robot.backRightMotor.setPower(-0.3);
+        robot.frontRightMotor.setPower(-0.3);
         }
 
 
@@ -670,11 +670,11 @@
 // Functions related to the wobble goal________________________________________________________________________________________________________
 
         void wobbleUp() {
-        robot.tiltServo.setPosition(0);
+        robot.tiltMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
         }
 
         void wobbleDown(){
-        robot.tiltServo.setPosition(1);
+        robot.tiltMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
         }
 
         void wobbleOpen() {
