Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\npackage org.firstinspires.ftc.teamcode;\r\n\r\nimport android.app.Activity;\r\nimport android.graphics.Color;\r\nimport android.view.View;\r\n\r\nimport com.qualcomm.hardware.rev.RevBlinkinLedDriver;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.robocol.Heartbeat;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\nimport com.qualcomm.robotcore.util.Range;\r\nimport com.qualcomm.robotcore.hardware.ColorSensor;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\n\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.AxesReference;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.Orientation;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.Locale;\r\n\r\n\r\n// this is the final teleop file\r\n// essentially, don't edit this unless its a change you're sure you want\r\n// if you want to make changes on this branch/mecanum stuff\r\n// use the MecanumWheelDraft file\r\n\r\n@TeleOp(name = \"UltimateGoalTeleOp\", group = \"Opmode\")\r\n//@Disabled\r\npublic class TeleOp1 extends LinearOpMode {\r\n\r\n    private ElapsedTime runtime = new ElapsedTime();\r\n    GrahamHWMap robot = new GrahamHWMap();\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n\r\n        robot.init(hardwareMap);\r\n\r\n        double x;\r\n        double y;\r\n        double r;\r\n        double frontLeft;\r\n        double frontRight;\r\n        double backLeft;\r\n        double backRight;\r\n\r\n        double step = .1;    //was .2    //how much to update\r\n        double interval = 25;  //was 75 // how often to update\r\n        double lastSpeedTime = runtime.milliseconds();\r\n\r\n        double max;\r\n\r\n        double launchMotorStatus = 0; // do not edit this\r\n        double launchMotorPower = 0; //do not edit this\r\n        double desiredLaunchPower = .85; // edit this for the power you want to motor to spin at\r\n\r\n        double intakeMotorStatus = 0; //do not edit this\r\n        double intakeMotorPower = 0; //do not edit this\r\n        double desiredIntakePower = .7; //edit this for the power you want the motor to spin at\r\n\r\n        // change the active and rest positions to change where each servo goes\r\n        double wobbleServoPosition = 0;\r\n        double WSactivePos1 = 0;\r\n        double WSactivePos2 = 0;\r\n        double WSrestPos1 = 0;\r\n        double WSrestPos2 = 0;\r\n\r\n        // change the active and rest positions to change where the servo goes\r\n        double launcherServoPosition = 0;\r\n        double LSactivePos = 0;\r\n        double LSrestPos = 0;\r\n\r\n        Orientation targOrientMain;\r\n        targOrientMain = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n        // Wait for the game to start (driver presses PLAY)\r\n        waitForStart();\r\n\r\n        while (opModeIsActive()) {\r\n\r\n            Orientation angles;\r\n\r\n            angles = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n\r\n\r\n            y = gamepad1.left_stick_y;\r\n            x = gamepad1.left_stick_x;\r\n            r = gamepad1.right_stick_x;\r\n\r\n\r\n            // do not let rotation dominate movement\r\n            r = r / 2;\r\n\r\n            // calculate the power for each wheel\r\n            frontLeft = +y - x + r;\r\n            backLeft = +y + x + r;\r\n\r\n            frontRight = -y - x + r;\r\n            backRight = -y + x + r;\r\n            /*\r\n            // Normalize the values so none exceeds +/- 1.0\r\n            max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n            if (max > 1.0) {\r\n                frontLeft = frontLeft / max;\r\n                frontRight = frontRight / max;\r\n                backLeft = backLeft / max;\r\n                backRight = backRight / max;\r\n            }\r\n\r\n             */\r\n\r\n            if (runtime.milliseconds() > lastSpeedTime + interval) {\r\n                lastSpeedTime = runtime.milliseconds();\r\n\r\n                frontLeft = getRampPower(frontLeft, robot.frontLeftMotor.getPower(), step);\r\n                frontRight = getRampPower(-frontRight, -robot.frontRightMotor.getPower(), step);\r\n                backLeft = getRampPower(backLeft, robot.backLeftMotor.getPower(), step);\r\n                backRight = getRampPower(-backRight, -robot.backRightMotor.getPower(), step);\r\n\r\n                frontRight = -frontRight;\r\n                backRight = -backRight;\r\n\r\n\r\n\r\n\r\n                max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n                if (max > .9) {   //was 1\r\n                    frontLeft = frontLeft / max;\r\n                    frontRight = frontRight / max;\r\n                    backLeft = backLeft / max;\r\n                    backRight = backRight / max;\r\n                }\r\n\r\n\r\n                robot.frontLeftMotor.setPower(frontLeft);\r\n                robot.frontRightMotor.setPower(frontRight);\r\n                robot.backLeftMotor.setPower(backLeft);\r\n                robot.backRightMotor.setPower(backRight);\r\n\r\n\r\n                // Show wheel power to driver\r\n                telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n                telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n                telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n                telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n                //telemetry.addData(\"current heading\", formatAngle(angles.angleUnit, angles.firstAngle));\r\n\r\n                telemetry.addData(\"back distance\", robot.backDistance.getDistance(DistanceUnit.MM));\r\n\r\n                telemetry.update();\r\n\r\n\r\n\r\n            }\r\n\r\n            //dont delete this -- this is what you gotta pass through the heading functions to if you want to keep the heading straight\r\n            // robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES\r\n\r\n// gamepad 1 - 111111111111111111111111111111111111111111\r\n            // driver launcher\r\n\r\n\r\n            if (gamepad1.a){\r\n                sleep(250);\r\n                if(launcherServoPosition == 0){\r\n                    robot.launcherServo.setPosition(LSactivePos);\r\n                    launcherServoPosition = 1;\r\n                }\r\n                if(launcherServoPosition == 1){\r\n                    robot.launcherServo.setPosition(LSrestPos);\r\n                    launcherServoPosition = 0;\r\n                }\r\n            }\r\n\r\n            if(gamepad1.x){\r\n\r\n            }\r\n\r\n            if(gamepad1.b){\r\n\r\n            }\r\n\r\n            //launcher motor\r\n            // turns the launcher motor on or off\r\n            if(gamepad1.y){\r\n                sleep(250);\r\n                if (launchMotorStatus == 0){ //if motor off\r\n                    launchMotorPower = desiredLaunchPower;  //turn motor on\r\n                    launchMotorStatus = 1;  // motor is on\r\n                }\r\n                else if (launchMotorStatus == 1){ // if motor on\r\n                    launchMotorPower = 0;       // turn motor off\r\n                    launchMotorStatus = 0;      // motor is off\r\n                }\r\n            }\r\n            robot.launcherMotor.setPower(launchMotorPower);\r\n\r\n\r\n            if(gamepad1.right_bumper){\r\n\r\n            }\r\n\r\n            if(gamepad1.left_bumper){\r\n\r\n            }\r\n\r\n// gamepad 2 - 22222222222222222222222222222222222222\r\n            // grabber collector\r\n\r\n            //intake motor\r\n            if(gamepad2.a){\r\n                sleep(250);\r\n                if(intakeMotorStatus == 0){ //if motor is off\r\n                    intakeMotorPower = desiredIntakePower; //turn motor on\r\n                    intakeMotorStatus = 1; //motor is on\r\n                }\r\n                else if (intakeMotorStatus == 1){ //if motor is on\r\n                    intakeMotorPower = 0;   //turn motor off\r\n                    intakeMotorStatus = 0; //motor is off\r\n                }\r\n            }\r\n            robot.intakeMotor1.setPower(intakeMotorPower);\r\n            robot.intakeMotor2.setPower(-intakeMotorPower);\r\n\r\n\r\n            // wobble servo button\r\n            // positions not yet calibrated -- all set to 0\r\n            if(gamepad2.x){\r\n                sleep(250);\r\n                if(wobbleServoPosition == 0){\r\n                    robot.wobbleServo1.setPosition(WSactivePos1);\r\n                    robot.wobbleServo2.setPosition(WSactivePos2);\r\n                    wobbleServoPosition = 1;\r\n                }\r\n                if(wobbleServoPosition == 1){\r\n                    robot.wobbleServo1.setPosition(WSrestPos1);\r\n                    robot.wobbleServo1.setPosition(WSrestPos2);\r\n                    wobbleServoPosition = 0;\r\n                }\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //used for ramp up driving\r\n    double getRampPower(double t, double a, double step) {\r\n        double delta;\r\n        double returnPower = 0;\r\n\r\n        delta = t - a;\r\n        if (delta > 0) {  // speeding up\r\n            returnPower = a + step;\r\n            if (returnPower > t) {\r\n                returnPower = t;\r\n            }\r\n        }\r\n        if (delta < 0) {  //slowing down\r\n            returnPower = a - (step);\r\n            if (returnPower < t)\r\n                returnPower = t;\r\n        }\r\n        if (delta == 0) {\r\n            returnPower = a;\r\n        }\r\n        return returnPower;\r\n    }\r\n\r\n    //rotates to the given heading\r\n    void rotateToHeading(double heading){\r\n\r\n        Orientation currentOrient;\r\n        currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n        double currentAngle = currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle);\r\n\r\n        for (double i = .3; i > .1; i = i-.1) {\r\n\r\n            blindRotateRight(i);\r\n            while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) > heading) && opModeIsActive()) {\r\n\r\n                currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n                telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n                telemetry.addData(\"target heading\", heading);\r\n                telemetry.update();\r\n            }\r\n            stopDriving();\r\n\r\n            blindRotateLeft(i);\r\n            while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) < heading) && opModeIsActive()) {\r\n\r\n                currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n                telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n                telemetry.addData(\"target heading\", heading);\r\n                telemetry.update();\r\n            }\r\n            stopDriving();\r\n        }\r\n\r\n\r\n\r\n        blindRotateRight(.175);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) > heading) && opModeIsActive()) {\r\n\r\n            currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n            telemetry.addData(\"target heading\", heading);\r\n            telemetry.update();\r\n        }\r\n        stopDriving();\r\n\r\n\r\n\r\n\r\n        blindRotateLeft(.175);\r\n        while ((currentOrient.angleUnit.DEGREES.normalize(currentOrient.firstAngle) < heading) && opModeIsActive()) {\r\n            currentOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            telemetry.addData(\"current heading\", formatAngle(currentOrient.angleUnit, currentOrient.firstAngle));\r\n            telemetry.addData(\"target heading\", heading);\r\n            telemetry.update();\r\n        }\r\n        stopDriving();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    //just rotates to the right\r\n    void blindRotateRight(double pwr){\r\n        pwr = -pwr; // -pwr on all wheels turns right\r\n        // Set power on each wheel\r\n        robot.frontLeftMotor.setPower(pwr);\r\n        robot.frontRightMotor.setPower(pwr);\r\n        robot.backLeftMotor.setPower(pwr);\r\n        robot.backRightMotor.setPower(pwr);\r\n\r\n    }\r\n\r\n    //just rotates to the left\r\n    void blindRotateLeft(double pwr){\r\n\r\n        robot.frontLeftMotor.setPower(pwr);\r\n        robot.frontRightMotor.setPower(pwr);\r\n        robot.backLeftMotor.setPower(pwr);\r\n        robot.backRightMotor.setPower(pwr);\r\n\r\n    }\r\n\r\n\r\n\r\n    //strafes left at the heading it was called at\r\n    void strafeLeft(double pwr, Orientation target) {\r\n\r\n        //orients\r\n        Orientation targetOrient;\r\n        Orientation currOrient;\r\n\r\n        //converts the target heading to a double to use in error calculation\r\n        targetOrient = target;\r\n        double targAng = targetOrient.angleUnit.DEGREES.normalize(target.firstAngle);;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n\r\n        //rChanger changes the sensitivity of the R value\r\n        double rChanger = 10;\r\n        double frontLeft, frontRight, backLeft, backRight, max;\r\n\r\n\r\n        while((opModeIsActive()) && (gamepad1.x)){\r\n\r\n            //gamepad.x is here as that is the button I've been pressing to test this function\r\n            //if you want to have this run properly, you'll need to replace gamepad.x with some other qualifier t\r\n            // that will stop the while loop at some point, some way\r\n\r\n\r\n            currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n\r\n            double error = targAng - currAng;\r\n\r\n\r\n            double r = (-error / 180) / (rChanger * pwr);\r\n            //double r = (-error/180);\r\n            //r = 0;\r\n            //r=-r;\r\n\r\n            if ((r < .07) && (r > 0)) {\r\n                r = .07;\r\n            } else if ((r > -.07) && (r < 0)) {\r\n                r = -.07;\r\n            }\r\n\r\n\r\n            // Normalize the values so none exceeds +/- 1.0\r\n            frontLeft = pwr + r ;\r\n            backLeft = -pwr + r ;\r\n            backRight = -pwr + r ;\r\n            frontRight = pwr + r ;\r\n\r\n            //original\r\n            // +    +\r\n            // -    +\r\n            // -    +\r\n            // +    +\r\n\r\n\r\n            //strafe right\r\n            // -    +\r\n            // +    +\r\n            // +    +\r\n            // -    +\r\n\r\n            max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n            if (max > 1.0) {\r\n                frontLeft = frontLeft / max;\r\n                frontRight = frontRight / max;\r\n                backLeft = backLeft / max;\r\n                backRight = backRight / max;\r\n            }\r\n\r\n\r\n\r\n            telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n            telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n            telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n            telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n            telemetry.addData(\"error\", error);\r\n\r\n            telemetry.addData(\"current heading\", formatAngle(currOrient.angleUnit, currOrient.firstAngle));\r\n            telemetry.addData(\"target heading\", formatAngle(targetOrient.angleUnit, targetOrient.firstAngle));\r\n\r\n            telemetry.update();\r\n\r\n            //send the power to the motors\r\n            robot.frontLeftMotor.setPower(frontLeft);\r\n            robot.backLeftMotor.setPower(backLeft);\r\n            robot.backRightMotor.setPower(backRight);\r\n            robot.frontRightMotor.setPower(frontRight);\r\n\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    //kills power ot all wheels\r\n    void stopDriving(){\r\n        robot.frontLeftMotor.setPower(0);\r\n        robot.frontRightMotor.setPower(0);\r\n        robot.backLeftMotor.setPower(0);\r\n        robot.backRightMotor.setPower(0);\r\n    }\r\n\r\n    //drives forward at the heading it was called at\r\n    // for example, calling this when the robot is at 60 heading, it will go to that heading, even if it gets knocked off course\r\n    void driveStraightTime(double pwr, Orientation target, double desiredTime){\r\n\r\n        //orients\r\n        Orientation targetOrient;\r\n        Orientation currOrient;\r\n\r\n\r\n        double lastTime = runtime.milliseconds();\r\n\r\n        //converts the target heading to a double to use in error calculation\r\n        targetOrient = target;\r\n        double targAng = targetOrient.angleUnit.DEGREES.normalize(target.firstAngle);;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n\r\n        //rChanger changes the sensitivity of the R value\r\n        double rChanger = 10;\r\n        double frontLeft, frontRight, backLeft, backRight, max;\r\n\r\n        while(((runtime.milliseconds() < lastTime + desiredTime) && (opModeIsActive()))){\r\n\r\n\r\n\r\n            currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n\r\n            double error = targAng - currAng;\r\n\r\n\r\n            double r = (-error / 180) / (pwr /* * rChanger*/);\r\n            //r = 0;\r\n\r\n            // Normalize the values so none exceeds +/- 1.0\r\n            frontLeft = pwr + r ;\r\n            backLeft = pwr + r ;\r\n            backRight = pwr - r ;\r\n            frontRight = pwr - r ;\r\n\r\n            frontLeft = -frontLeft;\r\n            backLeft = -backLeft;\r\n\r\n            max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n            if (max > 1.0) {\r\n                frontLeft = frontLeft / max;\r\n                frontRight = frontRight / max;\r\n                backLeft = backLeft / max;\r\n                backRight = backRight / max;\r\n            }\r\n\r\n\r\n\r\n            telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n            telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n            telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n            telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n            telemetry.addData(\"current heading\", formatAngle(currOrient.angleUnit, currOrient.firstAngle));\r\n            telemetry.addData(\"target heading\", formatAngle(targetOrient.angleUnit, targetOrient.firstAngle));\r\n\r\n            telemetry.update();\r\n\r\n            //send the power to the motors\r\n            robot.frontLeftMotor.setPower(frontLeft);\r\n            robot.backLeftMotor.setPower(backLeft);\r\n            robot.backRightMotor.setPower(backRight);\r\n            robot.frontRightMotor.setPower(frontRight);\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //drives straight for a desired distanced based off of the back distance sensor\r\n    void driveStraightDistance(double pwr, Orientation target, double desiredDistance){\r\n\r\n        //orients\r\n        Orientation targetOrient;\r\n        Orientation currOrient;\r\n\r\n\r\n        //converts the target heading to a double to use in error calculation\r\n        targetOrient = target;\r\n        double targAng = targetOrient.angleUnit.DEGREES.normalize(target.firstAngle);;  // target.angleUnit.DEGREES.normalize(target.firstAngle);\r\n\r\n        //rChanger changes the sensitivity of the R value\r\n        double rChanger = 10;\r\n        double frontLeft, frontRight, backLeft, backRight, max;\r\n\r\n        while(((robot.backDistance.getDistance(DistanceUnit.MM) < desiredDistance) && (opModeIsActive()))){\r\n\r\n            currOrient = robot.imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);\r\n            double currAng = currOrient.angleUnit.DEGREES.normalize(currOrient.firstAngle);\r\n\r\n            double error = targAng - currAng;\r\n\r\n\r\n            double r = (-error / 180) / (pwr /* * rChanger*/);\r\n            //r = 0;\r\n\r\n            // Normalize the values so none exceeds +/- 1.0\r\n            frontLeft = pwr + r ;\r\n            backLeft = pwr + r ;\r\n            backRight = pwr - r ;\r\n            frontRight = pwr - r ;\r\n\r\n            frontLeft = -frontLeft;\r\n            backLeft = -backLeft;\r\n\r\n            max = Math.max(Math.max(Math.abs(frontLeft), Math.abs(frontRight)), Math.max(Math.abs(frontRight), Math.abs(frontRight)));\r\n            if (max > 1.0) {\r\n                frontLeft = frontLeft / max;\r\n                frontRight = frontRight / max;\r\n                backLeft = backLeft / max;\r\n                backRight = backRight / max;\r\n            }\r\n\r\n\r\n\r\n            telemetry.addData(\"front left\", \"%.2f\", frontLeft);\r\n            telemetry.addData(\"front right\", \"%.2f\", frontRight);\r\n            telemetry.addData(\"back left\", \"%.2f\", backLeft);\r\n            telemetry.addData(\"back right\", \"%.2f\", backRight);\r\n\r\n            telemetry.addData(\"current heading\", formatAngle(currOrient.angleUnit, currOrient.firstAngle));\r\n            telemetry.addData(\"target heading\", formatAngle(targetOrient.angleUnit, targetOrient.firstAngle));\r\n\r\n            telemetry.update();\r\n\r\n            //send the power to the motors\r\n            robot.frontLeftMotor.setPower(frontLeft);\r\n            robot.backLeftMotor.setPower(backLeft);\r\n            robot.backRightMotor.setPower(backRight);\r\n            robot.frontRightMotor.setPower(frontRight);\r\n\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    String formatAngle(AngleUnit angleUnit, double angle) {\r\n        return formatDegrees(AngleUnit.DEGREES.fromUnit(angleUnit, angle));\r\n    }\r\n\r\n    String formatDegrees(double degrees) {\r\n        return String.format(Locale.getDefault(), \"%.1f\", AngleUnit.DEGREES.normalize(degrees));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp1.java	(revision fa03389c77d6c7b2860c120c193d9f74977131fb)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp1.java	(date 1613493751987)
@@ -204,7 +204,7 @@
                     launchMotorStatus = 0;      // motor is off
                 }
             }
-            robot.launcherMotor.setPower(launchMotorPower);
+            robot.launchMotor.setPower(launchMotorPower);
 
 
             if(gamepad1.right_bumper){
@@ -230,7 +230,7 @@
                     intakeMotorStatus = 0; //motor is off
                 }
             }
-            robot.intakeMotor1.setPower(intakeMotorPower);
+            robot.intakeMotor.setPower(intakeMotorPower);
             robot.intakeMotor2.setPower(-intakeMotorPower);
 
 
